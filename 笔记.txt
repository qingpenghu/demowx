1 原型与原型链
Object 是所有对象的爸爸，所有对象都可以通过 __proto__ 找到它
Function 是所有函数的爸爸，所有函数都可以通过 __proto__ 找到它
函数的 prototype 是一个对象
对象的 __proto__ 属性指向原型， __proto__ 将对象和原型连接起来组成了原型链
2 es6 let var const 
函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部
var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用
var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会
let 和 const 作用基本一致，但是后者声明的变量不能再次赋值
3 原型继承：组合继承 寄生继承 与 class继承
组合继承
核心是在子类的构造函数中通过 Parent.call(this) 继承父类的属性，然后改变子类的原型为 new Parent() 来继承父类的函数。
这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数
的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费
（组合继承缺点在于继承父类函数时调用了构造函数）
寄生继承
核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数
class继承
class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码
可以看成 Parent.call(this, value)。
当然了，之前也说了在 JS 中并不存在类，class 的本质就是函数(语法糖)
4 Proxy 
在 Vue3.0 中将会通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。
 Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。
 let p = new Proxy(target, handler)
 target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数
 5 跨域 Jsonp
 jsonp JSONP 的原理很简单，就是利用 <script> 标签没有跨域限制的漏洞。通过 <script> 
 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。 
 JSONP 使用简单且兼容性不错，但是只限于 get 请求

 5 操作dom慢原因
 因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，
 其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，
 也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题